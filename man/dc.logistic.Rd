% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dc.logistic.R
\name{dc.logistic}
\alias{dc.logistic}
\title{Title: Large scale high-dimensional logistic regression using the divide-and-conquer approach}
\usage{
dc.logistic(
  X,
  y,
  k,
  tau,
  penalty = "lasso",
  aggregate.method = "average",
  debias = F,
  ridge_lambda = 0.01
)
}
\arguments{
\item{X}{the design matrix}

\item{y}{the response vector}

\item{k}{the number of nodes to randomly and equally split the data}

\item{tau}{the thresholding parameter proportion to k deciding the number of votes needed to be in the final active set}

\item{penalty}{penalty method. Supported methods include 'lasso', 'SCAD' and 'MCP'}

\item{aggregate.method}{aggregation method. Supported methods include 'average', 'sparse' and 'weighted'}

\item{debias}{boolean parameter indicating whether to desparsify the estimate}

\item{ridge_lambda}{lambda parameter used in the regularized inverse of the debiasing step}
}
\value{
a list with the active set, all the local and the combined final estimators, and the running time.
}
\description{
This function runs large scale high-dimension logistic regression with the divide-and-conquer approach.
It still allows for penalty functions including LASSO, SCAD and MCP in estimation, and also allows for
debiasing operations for each local estimate. The active set is combined using majority voting, while
the final estimate is determined from the chosen aggregation method, which includes 'average', 'sparse',
and 'weighted'.
}
\examples{
# example code
p <- 1000
n <- 1000
s <- 30
k <- 5
tau <- 0.2
#' X <- matrix(rnorm(n * p), nrow = n, ncol = p)
beta <- sample(c(rep(10 / sqrt(s), s), rep(0, p - s)))
beta.active <- ifelse(beta != 0, 1, 0)
y <- ifelse(1 / (1 + exp(-X \%*\% beta)) > 0.5, 1, 0)
result <- dc.logistic(X, y, k, tau, penalty = "lasso")
print(result)
}
